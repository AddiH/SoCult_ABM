---
title: "Pseudocode"
author: "Astrid Elmann Hansen"
date: '2022-06-08'
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r}
pacman::p_load(tidyverse)
set.seed(35)
```


# Pure interdependence theory

All agents are connected

Friendships don't deteriorate

Agents can't be alone

cl_sat and cl_alt traits are constant pr. agent and independent of dyads

ka and kp are constant and identical for all agents

All agents opt to choose OwnMax in matrices

Joint control = 1

Uden intercept

> When sorting for higest sat - what if two are similar? How do we sort?

```{r notes}
# agent
for each agent
  cl_sat
  cl_alt
  for each dyad
    dep = sum (outcome – cl_alt) / ticks_spent_tog
    sat = sum (outcome – cl_sat) / ticks_spent_tog
    
# global
ka = 2
kp = 2
kj = 0

if dep = positive
  ac = ka/dep
  pc = dep/kp
  
if dep = negative
  ac = dep/ka
  pc = kp/dep

```

```{r tibble setup}
N <- 6 # number of agents
initial_dep <- 0.1 # the dependence value all dyads start with
initial_sat <- 0.1 # the satisfaction value all dyads start with

agents <- seq(1:N)
```


```{r tibble setup}
invit <- tibble(agent = as.numeric(agents), # create empty invit table with all agents 
                date = rep(FALSE,N), 
                to = as.numeric(rep(NA,N)), 
                with = as.numeric(rep(NA,N)))

hangout <- tibble(agent = numeric(), # create empty hangout table
                  date = logical(), 
                  to = numeric(), 
                  with = numeric())

sat <- sample(1:10, N^2, replace = TRUE)

dyads <- tibble(agent_1 = as.numeric(rep(1:N, each=N)), # create df with dyads and inital values
                agent_2 = as.numeric(rep(seq(1:N),N)),
                sat = sat,
                #sat = as.numeric(rep(initial_sat,N^2)),
                dep = as.numeric(rep(initial_dep,N^2)))
  
dyads <- dyads %>% filter(agent_1 != agent_2) # Remove dyads with the same agent twice

```

```{r test}
for (agent in invit$agents){ print(agent) }

rows <- sample(nrow(invit))
random_invit <- invit[rows, ]

for (agent in random_invit$agents){ print(agent) }
```

```{r}
while (nrow(invit) != 0) { # while some agents are left in invite-phase

  ############################### Send invites ###################################
    for (agent in invit$agent){ # each agent sends invites
      choice <- dyads %>% # make a df from dyads
        filter(agent_1 == agent) %>% # only choose current agent
        filter(!(agent_2 %in% invit)) %>% # remove agents that already have a date (are no longer in invit)
        arrange(desc(sat)) # sort so agent with higest sat is on top #@
        
      invit_agent <- choice$agent_2[1] # select top agent
      agent_index <- which(invit$agent == agent) # get the row number for the current agent in invit
      invit$to[agent_index] <- invit_agent # in invit set agent choice (might need where() here ?)
    }
####################### Check for mutual invites ###############################
    for (agent in invit$agent){ # each agent checks whether they have mutual invites
      #agent <- 2
      agent_index <- which(invit$agent == agent) # get the row number for the current agent in invit
      invit_agent <- invit$to[agent_index] # the agent i invited
      invit_agent_index <- which(invit$agent == invit_agent) # get the row number for the invit_agent in invit
        if (invit$to[invit_agent_index] == agent){ # if the invite from my invit_agent is to me
          invit$date[agent_index] <- TRUE # set that i have a date
          invit$with[agent_index] <- invit_agent # set that it is with the person i invited
        }
    }
############################ Update invit df ###################################          
  hangout_dyads <- invit %>% filter(date == TRUE) # select chosen dyads
  hangout <- rbind(hangout, hangout_dyads) # append dyads to hangout df
  invit <- invit %>% filter(date == FALSE)# remove agents with dates from invite
  rows <- sample(nrow(invit))
  invit <- invit[rows, ] # define new, shuffled invit

############################ Accept invites ####################################
    for (agent in invit$agent){
      agent <- 1
      a <- agent # annoying workaroud, filter() is confused otherwise
      agent_index <- which(invit$agent == agent) # get index of agent in invit
      if (invit$date[agent_index] == FALSE){ # Only look at agents without a date
        options <- invit %>% filter(to == a & date == FALSE) # make a df with agents that sent me invites, and are still available
      
        if (nrow(options) == 1){ # if i have one option
          agent_option <- options$agent[1] # the name of the one agent that sent me an invite
          agent_option_index <- which(invit$agent == agent_option) # index of agent_option
          invit$date[agent_index] <- TRUE # set that i have a date
          invit$with[agent_index] <- agent_option # set that it is with the person on my options list
          invit$date[agent_option_index] <- TRUE # set that other agent has a date
          invit$with[agent_option_index] <- agent # set that it is with me
        }
        
        if (nrow(options) > 1){ # if i have more than one option
          choice <- dyads %>% # make a df from dyads
          filter(agent_1 == agent) %>% # only choose current agent
          filter(!(agent_2 %in% options)) %>% # only choose agents that i have as options
          arrange(desc(sat)) # sort so agent with highest sat is on top #@
          
          agent_choice <- choice$agent[1] # the name of the top agent
          agent_choice_index <- which(invit$agent == agent_choice) # index of agent_choice
          invit$date[agent_index] <- TRUE # set that i have a date
          invit$with[agent_index] <- agent_choice # set that it is with the top agent
          invit$date[agent_choice_index] <- TRUE # set that other agent has a date
          invit$with[agent_choice_index] <- agent # set that it is with me
        }
      }
    }

############################ Update invit df ###################################          
  hangout_dyads <- invit %>% filter(date == TRUE) # select chosen dyads
  hangout <- rbind(hangout, hangout_dyads) # append dyads to hangout df
  invit <- invit %>% filter(date == FALSE)# remove agents with dates from invite

print("loop")
} # end of while loop
```

```{r}
# Hangout phase
for each dyad
  # generate matrix (a1b1, a2b1, a1b2, a2b2)
  for each agent
    a1b1 <- ac + pc + kj
    a2b1 <- ac + pc + kj
    a1b2 <- ac + pc + kj
    a2b2 <- ac + pc + kj
    
    choice <- higest()
  
```

---
title: "ABM"
author: "Astrid Elmann Hansen"
date: '2022-06-11'
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

**Format**

All agents are connected

Friendships don't deteriorate

Agents can't be alone

No joint action in matrix

ka and kp are constant and identical for all agents


TODO 

Add choice from type (own.etc)
More types of random intercepts?
Commit? or Com?


**Decisions not documented in original design**

*Invite probability*
Agents choose whom to invite based on probability. Low sat = low prob
of choosing to invite the agent. See code below from invitations.R

```{r eval=FALSE}
 # add the abs value of the min sat to all sat - lowest sat value is now 0
 abs_sort = sat + abs(min(sat))
 # add a row with probability of choosing each agent - finding %
 prob = abs_sort/sum(abs_sort) 
 # 1 random number between 1 and the number of rows in choice
 n <- sample(x = 1:nrow(choice), size = 1, prob = prob) 
```

*Comparison levels*
Agents cl_alt and cl_sat can be dynamic, and uniqe for each agent in every dyad. cl_alt is based on the X latest encounters with everyone but the relevant agent. cl_sat is based on the X latest encounters of the relevant agent. Both cl's are modified by two agent specific baselines, one for alt and one for sat. 
Cl's are updated at end of tick - meaning the cl noted next to an outcome is not the cl used for math - the cl of the previous row is. When calculating the CL's (see formula) "raw" outcomes are used, not previous outcomes adjusted with cls.

```{r}
pacman::p_load(tidyverse)
source("functions/dates.R")
source("functions/invitations.R")
source("functions/generate_matrix.R")
source("functions/matrix_choice.R")
source("functions/update_dyads.R")
empty_matrix <- read_csv("functions/empty_matrix.csv", show_col_types = FALSE)
```

>if dep = positive 
>ac = ka/dep 
>pc = dep/kp

>if dep = negative 
>ac = dep/ka 
>pc = kp/dep

```{r setup values}

ka <- 2
kp <- 2

N <- 20 # number of agents MUST BE EVEN NUMBER

ticks <- 1000 # how many ticks to run

sort <- "sat" # sort by sat or commit?

invite_function <- "probinvite" # prob or simple?

intercept <- "random" # random or none?

cl <- "dynamic" # dynamic or static?

cl_timeline <- 10 # number of encounters for calculating cl's (the agents memory)

```

```{r setup dyads}

sat <- sample(-10:10, N^2, replace = TRUE) # integers 
dep <- sample(-10:10, N^2, replace = TRUE) # integers 

# sat <- runif(N^2, min = -1) # uniform dist -1 to 1
# dep <- runif(N^2, min = -1) # uniform dist -1 to 1

# sat = as.numeric(rep(0.1,N^2)) # simple value
# dep = as.numeric(rep(0.1,N^2)) # simple value

```

```{r setup traits}

cl_alt_b <- sample(1:10, N, replace = TRUE)
cl_alt_b <- as.numeric(rep(cl_alt_b, each=N))

cl_sat_b <- sample(1:10, N, replace = TRUE)
cl_sat_b <- as.numeric(rep(cl_sat_b, each=N))

inv      <- sample(1:10, N, replace = TRUE)
inv      <- as.numeric(rep(inv, each=N))

cl_alt   <- sample(1:10, N*N, replace = TRUE)
cl_sat   <- sample(1:10, N*N, replace = TRUE)

```






> No touchy
**No touchy**
> No touchy

```{r setup dyads}
dyads <- tibble(agent_1 = as.numeric(rep(1:N, each=N)), # create df with dyads and inital values
                agent_2 = as.numeric(rep(seq(1:N),N)),
                sat = sat,
                dep = dep,
                commit = 0,
                tick_no = 0,
                ticks_tog = 0,
                
                outcome = 0, # (these four are cleared after each tick but saved in dyads_his)
                out_sat = 0,
                out_dep = 0,
                date = F,
                ac = 0,
                pc = 0,
                
                cl_alt_b = cl_alt_b,
                cl_sat_b = cl_sat_b,
                cl_alt = cl_alt,
                cl_sat = cl_sat,
                inv = inv
                )
  
dyads <- dyads %>% filter(agent_1 != agent_2) # Remove dyads with the same agent twice

dyads_his <- dyads
```


```{r}
start <- proc.time() # start a stopwatch

for (tick in 1:ticks){

  hangout <- dates(N = N, dyads = dyads, sort = sort, invite_function = invite_function) # set up date pairs

for (i in 1:nrow(hangout)){ # for every dyad
  
  A <- hangout$A[i] # get the "name" of each agent
  B <- hangout$B[i]
  
  matrix <- generate.matrix(A = A, B = B, matrix = empty_matrix, 
                            dyads = dyads, ka = ka, kp = kp, intercept = intercept) # generate matrix  
  
  A_choice <- own.max(agent = "A", matrix = matrix) # each agent chooses
  B_choice <- own.max(agent = "B", matrix = matrix)

  dyads <- update.dyads(A = A, B = B, A_choice = A_choice, B_choice = B_choice, 
                        matrix = matrix, dyads = dyads, tick = tick, cl = cl, cl_timeline = cl_timeline) # update dyads with new outcomes, tick_tog, sat and dep, AND CL's IF relevant
}

dyads <- dyads %>% mutate(tick_no = tick) # for history dyads
dyads_his <- bind_rows(dyads_his, dyads) # add this tick dyad to dyad_his
dyads <- dyads %>% mutate(outcome = 0, out_dep = 0, out_sat = 0, date = F, ac = 0, pc = 0) # reset outcomes and date status
  
print(sprintf("Tick %s of %s", tick, ticks))

}
filename <- sprintf("logfiles/%s_ticks_%s_agents_%s_%s_%s_%s.csv", ticks, N, sort, invite_function, cl, cl_timeline)
dyads_his  %>% write_csv(filename)

proc.time() - start # get stopwatch time
```

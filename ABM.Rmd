---
title: "ABM"
author: "Astrid Elmann Hansen"
date: '2022-06-11'
output: html_document
---


> Issues:

No penalty for not cooperating
Agents have no reason to prioritize more than one person
When sorting for higest sat - what if two are similar? How do we sort?
> Simple: random choice




> intercept, 4 forskellige "grundtyper" arbejd samme imod etc eller random evt. kod begge dele
> evt. cost penalty på ikke at arbejde sammen

TODO
Viz in own file - loads in his_dyad
Update outcomes to function
Add intercept + cost penalty
Make his_dyads
Viz sat + dep
Git pull ignore plots
Add choice from type (own.etc)


# Pure interdependence theory

All agents are connected

Friendships don't deteriorate

Agents can't be alone

ka, kp and kj are constant and identical for all agents

cl_sat and cl_alt traits are constant pr. agent and independent of dyads

dep = dep + ((outcome – cl_alt) / ticks_spent_tog)

sat = sat + ((outcome – cl_sat) / ticks_spent_tog)
    
ka = 2
kp = 2
kj = 0

if dep = positive
  ac = ka/dep
  pc = dep/kp
  
if dep = negative
  ac = dep/ka
  pc = kp/dep



```{r}
pacman::p_load(tidyverse)
source("functions/dates.R")
source("functions/invitations.R")
source("functions/generate_matrix.R")
source("functions/matrix_choice.R")
source("functions/get_outcome.R")
empty_matrix <- read_csv("functions/empty_matrix.csv")
```

```{r setup values}
ka <- 2
kp <- 2

N <- 10 # number of agents

sort <- "sat" # sort by sat or commit?

invite_function <-"prob.invite" # which invite function to use?

ticks <- 10 # how many ticks to run

```

```{r setup dyads}
sat <- sample(-10:10, N^2, replace = TRUE) # integers 
dep <- sample(-10:10, N^2, replace = TRUE) # integers 

# sat <- runif(N^2, min = -1) # norm 
# dep <- runif(N^2, min = -1) # norm 

#sat = as.numeric(rep(initial_sat,N^2)) # simple value
#dep = as.numeric(rep(initial_dep,N^2)) # simple value

dep[dep==0] <- 0.001 # lololol

dyads <- tibble(agent_1 = as.numeric(rep(1:N, each=N)), # create df with dyads and inital values
                agent_2 = as.numeric(rep(seq(1:N),N)),
                sat = sat,
                dep = dep,
                ticks_tog = 0,
                outcome = 0)
  
dyads <- dyads %>% filter(agent_1 != agent_2) # Remove dyads with the same agent twice

dyads_his <- dyads %>% mutate(tick = 0) # history dyads
```

```{r setup traits}
traits <- tibble(agent = as.numeric(seq(1:N)),
                 cl_alt = sample(-10:10, N, replace = TRUE),
                 cl_sat = sample(-10:10, N, replace = TRUE))
```

```{r}
ptm <- proc.time() # start a stopwatch

for (tick in 1:ticks){

hangout <- dates(N = N, dyads = dyads, sort = sort, invite_function = invite_function) # set up date pairs

for (i in 1:nrow(hangout)){ # for every dyad
  
  A <- hangout$A[i] # get the "name" of each agent
  B <- hangout$B[i]
  
  matrix <- generate.matrix(A = A, B = B, matrix = empty_matrix, dyads = dyads, ka = ka, kp = kp) # generate matrix
  
  A_choice <- own.max(agent = "A", matrix = matrix) # each agent chooses
  B_choice <- own.max(agent = "B", matrix = matrix)

  
  
  # update sat and dep for A
  
      A_outcome <- get.outcome(A_choice = A_choice, B_choice = B_choice, matrix = matrix, agent = "A") # get outcome
      B_outcome <- get.outcome(A_choice = A_choice, B_choice = B_choice, matrix = matrix, agent = "B") # get outcome
    
      
############ Make into function##########################
      A_B <- which(dyads$agent_1 == A & dyads$agent_2 == B) # find the row no for the relevant dyad
    
      dyads$ticks_tog[A_B] <- dyads$ticks_tog[A_B] + 1 # add a tick to ticks spent together
      
      dyads$sat[A_B] <- dyads$sat[A_B] + ((A_outcome - traits$cl_sat[A]) # update sat
                                            /dyads$ticks_tog[A_B])
      
      dyads$dep[A_B] <- dyads$dep[A_B] + ((A_outcome - traits$cl_alt[A]) # update dep
                                            /dyads$ticks_tog[A_B])
      
  # repeat for B

      B_A <- which(dyads$agent_1 == B & dyads$agent_2 == A) # find the row no for the relevant dyad
      
      dyads$ticks_tog[B_A] <- dyads$ticks_tog[B_A] + 1 # add a tick to ticks spent together
      
      dyads$sat[B_A] <- dyads$sat[B_A] + ((A_outcome - traits$cl_sat[B]) # update sat
                                            /dyads$ticks_tog[B_A])
      
      dyads$dep[B_A] <- dyads$dep[B_A] + ((A_outcome - traits$cl_alt[B]) # update dep
                                            /dyads$ticks_tog[B_A])
}

dyads_tick <- dyads %>% mutate(tick = tick) # history dyads
dyads_his <- bind_rows(dyads_his, dyads_tick) # add this tick dyad to dyad_his
dyads <- dyads %>% mutate(outcome = 0) # reset outcomes
  
print(sprintf("Tick %s of %s", tick, ticks))

}

proc.time() - ptm # get stopwatch time
```




